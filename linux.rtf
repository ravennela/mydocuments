{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9\tab\tab\tab\tab\tab\fs48 Linux \par
\par
\fs28 what is UNIX?\par
- - - - - - - - - - - -  -\par

\pard\ri-449\sa200\sl240\slmult1\tx142\tx426\tx994\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 It is an operating system created in 1960s.\par
with lot of extensions and improvements to base versions, several flavers introduced by orgonisations /companies (RedHat Linux, Ubuntu,Suse...)\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994\b Charecterstics of Unix\b0 :\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 - - - - - - - - - - - - - - - - - -\par
1) It is Free ware \par
2) It is open source software \par
     It is FOSS (Free ware and Open source software)\par
3) It is multi user operating system.\par
4) It is Multi tasking operating system.\par
5) It is user friendly and supports both cui based and gui based. \par
6) It is More Secure than Windows Operating System.\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994\b Flavors of UNIX\b0 :\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 - - - - - - - - - - - -\par
Ubuntu \par
RedHat Linux\par
CentOs\par
Fedora\par
slackware \par
Open Solaries\par
Kali\par
Suse Linux Enterprice Server(SLES)\par
open Suse\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994\b Components of  UNIX\b0 :\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 - - - - - - - - - - - - - - - - - \par
Two important components are there :\par
 Shell\par
Kernal\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994 1) Shell:\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994   - - - - - \par
It is outer layer of Unix operating system.\par
Shell reads commands provided by user.\par
Shell will check is it valid command or not.\par
Shell will check is it properly used or not.\par
If every thing is proper, then shell interprets/converts that command into kernel understandable form and handover to that to the kernel.\par
shell acts as interface between user and kernel.\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994 2) Kernal:\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994   - - - - - - -\par
It is the core component of UNIX operating Sysytem.\par
It is responsible to execute our commands with the help of hardware components.\par
Memory allocation and processor allocation will takes care by kernel.\par
It acts as interface bitween shell and hardware components.\par
\par
normal user ==> $ prompt\par
super user /root user/admin  user ==> # prompt \par
sudo -i  ===>To switch to super user\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994 Online UNIX  Terminal :\par
- - - - - - - - - - - - - - - - - -\par
{{\field{\*\fldinst{HYPERLINK http://www.masswerk.at/jsuix }}{\fldrslt{http://www.masswerk.at/jsuix\ul0\cf0}}}}\f0\fs28\par
\par
\par
\b The most commonly used basic commands\b0  :\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \par
1) pwd  --> print working directory\par
\par
2) ls  --> list out all files and directories.\par
\par
3) mkdir --> To create/ make a directory.\par
\par
4) cd  --> change directory\par
\par
5) touch --> to create an empty file\par
\par
6) rmdir --> to remove a directory\par
\par
7) rm --> to remove a file.\par
\par
8) cal --> display current month calender\par
\par
9)date --> display current date and time.\par
\par
10) help --> To display list of available commands.\par
\par
11) clear --> To clear the terminal.\par
\par
12)  exit --> To logout session\par
\par
13) hello --> To display brief system information \par
\par
\par
\b\fs32 Linux File System :\b0\fs28\par
- - - - - - - - - - - - - - - \par
\par
\b Types of Files in Linux:\par
- - - - - - - - - - - - - - - - - \par
\par
\b0 In python everything is treated as an object.\par
\par
In Linux everything is treated as a file.\par
\par
1) Normal files or ordinary files.\par
\par
2) Directory Files\par
\par
3) Device Files.\par
\par
\b 1) Normal files or ordinary files:\par
\b0 - - - - - - - - - - - - - - - - - - - - - - - - \par
These files contain data. It can be normal text file or binary files (images,video,audio files etc..)\par
\par
abc.txt\par
test.sh\par
test.py\par
Test.java\par
sunny.jpg\par
bahubali.mp4\par
\par
In Linux file extension is not important. based on our content the linux can identify file type.\par
\par
\b 2) Directory files:\b0\par
 - - - - - - - - - - - - -\par
\par
These files represent directories .\par
In Windows, we can use folder terminology but in linux we can use directory terminology.\par
directory contains files and sub directory also.\par
\par
\b 2) Device files:\b0\par
 - - - - - - - - - - - - -\par
In Linux every device is represented as a file.\par
By using this file we can communicate with that device.\par
Inside  /dev directory all device related files will be there.\par
\par
tty is used to get the current terminal location.\par
\par
terminal 1====>  /dev/pts/0\par
terminal 2 ====> /dev/pts/1\par
\par
\b Note:\par
\b0 ctrl+alt+t ===> To open terminal \par
ctrl+d       ===>  To close terminal\par
\par
\b How to Check file type:\par
- - - - - - - - - - - - - - - - - - \par
\par
\b0 In ubuntu:\par
blue colour files represents :directories\par
remaining :ordinary files\par
\par
we have to use ls -l   command to find out file type.\par
\par
The First charector represents the type of file\par
\par
d ---> directory file\par
 -    ===> ordinary file\par
l   ====>link file\par
\par
\par
c ===> charector special file\par
b ===> block special file\par
s ====> socket file\par
\par
\par
\b File System navigation Commands:\par
-  - - - - - - - - - - - - - - - - - - - - - - - - - - \par
\par
\b0 hidden files and hidden directories\par
\par
ls \par
ls  -a\par
     -a means all \par
\par
. represents current directory\par
. .  represents parent directory\par
\par
/home/durga/Desktop/dir1/dir2\par
\par
if you are in dir2\par
\par
current directory :dir2\par
parent directory :dir1\par
\par
cd command\par
\par
1) $ cd .\par
  changes to current directory (useless)\par
\par
2) $ cd . .\par
  changes to parent directory\par
\par
3)$ cd . ./. ./. ./. .\par
\par
4)$ cd ~\par
    To go to user home directory\par
\tab   /home/durga\par
\par
5) $ cd \par
    cd command   without  any argument \par
\tab  To go to user home directory\par
\tab  /home/durga \par
\par
6) $ cd -\par
\tab    If we want to go previous working directory\par
\par
\par
\par
\b Linux File System Hierarchy :\par
- - - - - - - - - - - - - - - - - - - - - - \par
\par
\b0 Linux file system has Tree like structure.\par
It starts with root(/)\par
/ is th topmost directory\par
\par
sub directories:\par
bin   etc    home     lib     dev       usr cdrom  \par
\par
\b 1) bin directory :\b0  \par
- - - - - - - - - - - - -\par
bin means binary \par
It  contains all binary excecutable related to our linux commands.\par
\par
touch \par
ls \par
mkdir\par
cd \par
\par
\b 2) sbin directory:\par
- - - - - - - - - - - - - \par
\b0 sbin means systembin.\par
normal user commands related binary executable files available in bin directory.\par
\par
super user used commands related binary executable files available in bin directory.\par
\par
Disk partitioning \par
Network management\par
\par
\b 3) etc directory:\par
- - - - - - - - - - - - - \b0   \par
This directory contains all system configuration files.\par
These configuration files can be used by operating system itself.\par
\par
/etc/passwd  ==> All users information.\par
/etc/group    ==> All groups information\par
/etc/hosts     ==> All hosts information( ip address and dns names).\par
\par
 \b 3) tmp directory:\par
  - - - - - - - - - - - - -\par
\par
\par
\par
\fs36 Installing Linux Operating System:\par
- - - - - - - - - - - - - - - - - - - - - - - - - - -\par
\par
\b0\fs28 step1: oracle virtual box installation\par
\par
step2: Ubuntu installation\par
\par
\b Need of Virtual box:\b0\par
\b - - - - - - - - - - - - - - - \par
\b0 To run virtual computers in our system without effecting original computer \par
\par
Computer ===>\par
Virtual Box ===>\par
         Virtual computer ===> Linux \par
\tab\tab   Virtual Computer ===> Mac\par
         Virtual Computer ===> Sun solaries\par
\par
By using this virtual box we can run multiple operating system simultanously.\par
\par
\par
\b Oracle Virtual Box Installation:\par
- - - - - - - - - - - - - - - - - - - - - - - -\par
\par
\b0 Download virtual box software from virtualbox.org\b\par
\b0\par
In this virtual box, we have to create virtual computer with ubuntu operating system\par
\par
ubuntu software must be required.\par
 download ubuntu from ubuntu.com\par
\par
\par
1. ls command:\par
- - - - - - - - - - - \par
list out all files and directories present in the given directory.If we are not providing any directory then it will list out in current working directory.\par
$ ls dir1\par
$ ls\par
$ man command\par
$ man ls\par
various options for ls commands:  \par
- - - - - - - - - - - - - - - - - - - - - - - - \par
1. ls \par
It will list out all files and directories present in current working directory in alphabetical order.\par
2. ls -r \par
-r means reverse \par
It will list out all files and directories  in riverse of alphabetical order.\par
\par
3. ls -l \par
To display in long listing form \par
\par
-rw-r - - r - - 1  durga durga                0  Mar 23  12:40  abcdef.txt\par
 \par
\par
4. ls -t\par
-t means creation or last modified time.\par
Most recent will be at the top and old are at the bottom.\par
5. ls -ltr\par
old files should be at top and most recent should be at bottom.\par
6. ls -a \par
 -a means all.\par
7. ls -A\par
-A means almost all\par
except  . and . .  all remaining things will be displayed \tab\par
8. ls -F\par
To display all files by type\par
directory  ----> /\par
executable file ----> *\par
link file -----> @\par
9. ls -f \par
list out all files including hidden files but disable  colors.\par
10. ls  -i\par
To display all files including inode number \par
inode ===>index node\par
i- node is the adress of location where file attributes are stored. file attributes includes\par
The size of the file.\par
The number of links in the file.\par
owner name\par
group name\par
creation time\par
last modified time\par
11. ls -R\par
  -R Means recursive\par
which is used to show all sub directories in each individual sub directory.\par
12. ls -s \par
-s means size \par
the number of blocs used \par
1 block =1kB or 4KB\par
13. ls -h\par
-h means human readable form for memory statistics.\par
\par
Note:\par
ls  -l  /etc  ===> 212 entries\par
ls  -l  |  head  ====> top 10 entries\par
ls   -l  | head  -20  ===> top 20 entries\par
ls   -l  | head -30   ====> top 30 entries\par
ls   -l   | tail   ===> last 10 lines\par
\par
ls  -l  /etc  | more   ===> only in farward direction \par
ls  -l  /etc  | less    ===> both in forward and backward direction\par
\par
\par
Command Line Arguments:\par
- - - - - - - - - - - - - - -- - - - - - \par
The  Arguments which are passing from command prompt  ===> \par
$   ./test.sh  10   20   30   40\par
\tab         10,20,30,40\par
$  ./test.sh   learning linux is very easy \par
learning, linux, is, very,easy\par
$ #  ----> Number of arguments  (5)\par
$ 0  -----> Script Name (./test.sh)     test.sh ====> /home/durga/ scripts /test.sh\par
$ 1  -----> First argument (learning) \par
$ 2  -----> Second argument (linux)\par
$ 3  ----- > Third argument (is)\par
$ 4 -----> Fourth argument ( very)\par
$ 5  -----> Fifth argument (easy)\par
$ *  ------> all arguments  (learning linux is very easy)\par
$ @ ------> All arguments ( learning linux is very easy)\par
$ ?  -------> Represents exit code of Previuosly executed  command or Script.\par
\par
test.sh File \par
#!   /bin /bash\par
echo   "The number of arguments  : $#"\par
echo  "Script file name : $0"\par
echo "First argument :$1"\par
echo "Second argument: $2"\par
echo "Third argument : $3"\par
echo "Fourth argument :$4"\par
echo "Fifth  argument :$5"\par
echo "All arguments with * : $*"\par
echo "all arguments with @ :$@"\par
\par
Difference between $@ and $*:\par
- - - - - - - - - - - - - - - - -- - - - - -\par
$@:  -----> All commands line arguments with space seperator.\par
                     "$1"    "$2"   "$3"   "$4"    "$5"\par
                     learning linux is very easy\par
$*   ------>  All  command line arguments as single  string .\par
                     "$1c$2c$3c$4c$5"\par
                     where c is the first charecter of the IFS  (Internal file seperator) . The default is \tab\tab     space .\par
\tab    learning  linux is very easy.\par
\par
How to check default  IFS :\par
- - - - - - - - - - - - - - - - -  - - -\par
$ set  | grep  "IFS"\par
\par
IFS =$  '   \\t\\n'\par
\b\par
What is the main purpuse of command line arguments:\par
- - - - - - - - - - - - - - - - -  - - - - -  - - - - - -- - - - - - - - - - - - - - - \par
\par
\b0 we can customize behaviour  of the script Based on our arguments the script will work.\par
\par
test.sh:\par
- - - - - \par
\par
#! /bin/bash\par
len = $(echo -n "APPLE" | wc -c)\par
echo "The length of given string :$len"\par
\par
The script will always work for the string :APPLE\par
\par
test.sh:\par
- - - - - -\par
#! /bin /bash\par
\par
len =$(echo -n "1$" |wc -c)\par
echo "The length of given String $1 : $len"\par
\par
\par
\b Variable Substitution and command substitution:\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\par
\par
write a script to create a log file with time stamp:\par
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - -\par
\par
\b0 test.sh:\par
- - - - - \par
#!  /bin/bash\par
\par
timestamp = $ (date  +%d_%m_%Y_%H_%M_%S)\par
\par
echo "Hello " > abc.text   overwrite existing data\par
echo "Hello"  >> abc.txt   append to existing data\par
echo  "This is data to log file " >> $ \{timestamp\}.log\par
date  >> $ \{timestamp\}.log\par
\par
\par
\par
\b\fs32 How to view content of the file:\par
\b0\fs28 - - - - - - - - - -  - - - - - - - - - - - - - - - - - - -\par
we can view the content of the file by using the following commands:\par
\par
1. cat \par
2. tac\par
3. rev\par
4. head\par
5. tail\par
6. more \par
7. less\par
 \par
\b View content by using cat:\par
- - - - - - - - - - - - - - - - - - - - -\par
\b0 cat  < file.txt\par
where  < is optional.\par
cat file1.txt\par
\par
while display data if we want line numbers, we have to use -n option.\par
cat  -n file1.txt\par
\par
Numbering skipped for blank lines then we should use -b option\par
\par
\b To View Multiple files content simultanously:\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \par
\b0 cat file1.txt   file2.txt    file3.txt   \par
\par
\b Various utilities of cat command:\b0\par
- - - - - - - - - - - - - - - - - - - - - - - - - \par
\par
1. create a new file with some content \par
\par
cat > file1.txt\par
required data\par
ctrl+d   ---> to save and exit\par
\par
2. To append some extra data to an existing file:\par
\par
cat  > > file1.txt\par
some more extra data\par
ctrl+d  ----> to save and exit\par
\par
3. To view content of the \tab file:\par
\par
cat < file1.txt      or     cat  file1.txt\par
\par
4 . To copy content of one file to onether file:\par
\par
cp file.txt    file2.txt\par
\par
cat file1.txt   > file2.txt\par
\par
5. To append one file to onether file:\par
\par
cat    file1.txt  >>   file2.txt\par
\par
6. To copy contents of multiple files to a single file:\par
\par
cat  a.txt    b.txt    c.txt   d.txt     >total.txt\par
\par
\b\fs32 2. tac command\par
\par
\b0\fs28 It is the reverse of cat \par
\par
It will display file content in riverse order of lines.\par
\par
this is vertical riversal.\par
\par
\par
Sunny \par
Bunny \par
chinny\par
vinny\par
pinny\par
\par
\par
Pinny\par
vinny\par
chinny\par
bunny\par
sunny\par
\par
\b\fs32 3. rev command:\par
\b0\fs28\par
rev means reversal.\par
Here each line will be reversed.\par
It is horizontal reversal.\par
\par
\par
Sunny \par
Bunny\par
Chinny\par
Vinny\par
Pinny\par
\par
\par
\par
ynnuS\par
ynnuB\par
ynnuhC\par
ynnuV\par
ynnuP\par
\par
\par
cat command will display total file content at a time. It is best suitable for small files. If the file contains thousands of lines it is not recommended to use cat command. For this requirement we should go for\par
\par
head \par
tail\par
more \par
less\par
\par
\par
\b\fs32 head command:\b0\fs28  \par
- - - - - - - - - -- - - - - \par
\par
To view specified number of lines from top of the file \par
\par
head  abc.txt\par
\par
It will display only 10 lines from top of file .\par
10 is the default value for head command.\par
\par
head  -n  15 abc.txt     or    head    -15    abc.txt\par
\par
head -5  abc.txt\par
\par
head  -n   -5  abc.txt \par
It will display all lines from top except last 5 lines.\par
\par
head -c  100  abc.txt\par
\par
It will display the first 100 charectors of the file \par
\par
In linux every charector will take one byte. Hence it will display first 100 bytes of the file  Content. \par
\par
\b\fs32 tail command:\b0\fs28  \par
- - - - - - - - - - - -- - \par
\par
To view file content from bottom of the file  ---> tail command \par
It is opposit to head command.\par
\par
1. tail   abc.txt\par
Last 10 lines will be dispayed\par
\par
2. tail -n 5  abc.txt\par
 Last 5 lines \par
\par
 tail -5  abc .txt \par
  Last 5 lines \par
\par
tail -5 -n abc.txt\par
Last 5 lines           //in head command except last 5 remaining will display but here that is not implimented\par
\par
3. tail -c 100 abc.txt\par
    It will display 100 bytes of content from bottom of the file.\par
\par
Q. Assume file contains enough data. \par
\par
write command to display from 3rd line to 7th line?\par
\par
head  -7 abc.txt  | tail -5 \par
\par
\b\fs32 Word count command ( wc command ) :\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\par
\par
\b0\fs28 we can use wc command to count number of lines,words and charectors present in the given file\par
\par
$ wc  filename \par
 \par
no_of_lines       no_of_words      no_of_charectors    file_name\par
\par
durga@durga - VirtualBox:~/Desktop$   wc file1.txt\par
 4    24     135   file1.txt \par
\par
\par
4  -----> No of lines\par
24 -----> No of words \par
135 ----> No of charectors ( no of bytes or filesize)\par
\par
we can use the following options with wc command \par
\par
-l      ====> To print only number of lines \par
-w    ====> To print only number of words \par
-c     ====> To print only number of charectors\par
-lw   ====> To print only number of lines and words\par
-lc    ====> To print only number of lines and charectors\par
-wc  ====> To print only number of words  and charectors\par
-L     =====>To print number of charectors present in Longest Line \par
\par
We can use  wc command for multiple files simultanously.\par
\par
wc  a.txt  b.txt  c.txt\par
\par
durga@durga - VirtualBox:~/Desktop$   wc file1.txt    file2.txt   file3.txt\par
\par
4    24    135    file1.txt\par
4    24    135   file2.txt\par
3    9      47      file3.txt\par
11  57   317    total\par
\par
\par
\par
\b\fs32 What is Piping:\b0\fs28   \par
- - - - - - - - - - - - - \par
some times we can use output of one command as an input to other command. This concept is called piping.\par
\par
By using piping, multiple commands will work together to fulfill  our requirements\par
\par
we can implement piping by using vertical bar  (|)\par
\par
eg-1:\par
durga@durga-VirtualBox:~Desktop$   ls -l  /etc | wc -l\par
222\par
\par
standard output of ls command will become standard input to wc command \par
\par
eg -2:\par
ls -l /etc  | more\par
\par
eg -3:\par
ls -l  /etc  |  head -5\par
\par
eg -4 : ls -l  /etc  | wc  |wc -1\par
\par
the output is always 1.\par
\par
\b Requirement:\b0  \par
The output of ls command should be saved to the file  output.txt  and should be provided as input to wc command ?\par
\par
ls - l  > output.txt  | wc  -l\par
\par
In the middle of piping if we use redirection then it breaks piping concept.\par
\par
ls -l\par
\par
\par
\b tee command:\par
- - - - - - - - - - - \par
\par
\b0 ls  - l  | tee  output.txt  |wc\par
\par
In piping, if we want to save the output of one command to a file and if we want to pass that output as input to next command simoultaniously  then we should use tee command .\par
\par
eg1:  To save the output of ls command to a fille and display to the terminal simultaneously\par
\par
ls   - l   | tee output.txt\par
\par
eg 2:\par
If i want to save the result of ls -l in output.txt and pass the output to wc command and save that output in wc.txt ?\par
\par
ls -l  | tee output.txt |wc  | tee  wc.txt\par
\par
\par
\b Requirement 2:\par
- - - - - - - - - - - \par
 \b0 Assume input.txt  contains filenames.\par
\par
input.txt\par
- - - - - - \par
\par
file1.txt \par
file2.txt\par
file3.txt\par
\par
Read file names from the input.txt  and remove each file.\par
\par
cat input.txt  ===> standard output \par
rm  file1.txt    file2.txt   file3.txt    ===>  remove 3 files\par
\par
remove command always expecting from command line arguments only.\par
 But in piping the input is always stream.\par
\par
cat   input.txt | rm\par
\par
we have to convert that stream into command line arguments\par
\par
xargs  command:\par
- - - - - - - - - - - - \par
cat  input.txt  | xargs  rm\par
\par
xargs command:  to convert output stream into command line argument  \b\par
\par
\par
\par
\b0\par
\par
\b\fs32\par
\b0\fs28\par
\par
\par
\par
     \par
\par
\b\fs32\par
\b0\fs28\par
\par
\par
\par
 \fs22\par

\pard\sa200\sl276\slmult1\par
}
 