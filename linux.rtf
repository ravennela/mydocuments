{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.22621}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9\tab\tab\tab\tab\tab\fs48 Linux \par
\par
\fs28 what is UNIX?\par
- - - - - - - - - - - -  -\par

\pard\ri-449\sa200\sl240\slmult1\tx142\tx426\tx994\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 It is an operating system created in 1960s.\par
with lot of extensions and improvements to base versions, several flavers introduced by orgonisations /companies (RedHat Linux, Ubuntu,Suse...)\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994\b Charecterstics of Unix\b0 :\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 - - - - - - - - - - - - - - - - - -\par
1) It is Free ware \par
2) It is open source software \par
     It is FOSS (Free ware and Open source software)\par
3) It is multi user operating system.\par
4) It is Multi tasking operating system.\par
5) It is user friendly and supports both cui based and gui based. \par
6) It is More Secure than Windows Operating System.\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994\b Flavors of UNIX\b0 :\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 - - - - - - - - - - - -\par
Ubuntu \par
RedHat Linux\par
CentOs\par
Fedora\par
slackware \par
Open Solaries\par
Kali\par
Suse Linux Enterprice Server(SLES)\par
open Suse\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994\b Components of  UNIX\b0 :\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994 - - - - - - - - - - - - - - - - - \par
Two important components are there :\par
 Shell\par
Kernal\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994 1) Shell:\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994   - - - - - \par
It is outer layer of Unix operating system.\par
Shell reads commands provided by user.\par
Shell will check is it valid command or not.\par
Shell will check is it properly used or not.\par
If every thing is proper, then shell interprets/converts that command into kernel understandable form and handover to that to the kernel.\par
shell acts as interface between user and kernel.\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994 2) Kernal:\par

\pard\ri-448\sa200\sl276\slmult1\tx142\tx426\tx994   - - - - - - -\par
It is the core component of UNIX operating Sysytem.\par
It is responsible to execute our commands with the help of hardware components.\par
Memory allocation and processor allocation will takes care by kernel.\par
It acts as interface bitween shell and hardware components.\par
\par
normal user ==> $ prompt\par
super user /root user/admin  user ==> # prompt \par
sudo -i  ===>To switch to super user\par
\par

\pard\ri-449\sl240\slmult1\tx142\tx426\tx994 Online UNIX  Terminal :\par
- - - - - - - - - - - - - - - - - -\par
{{\field{\*\fldinst{HYPERLINK http://www.masswerk.at/jsuix }}{\fldrslt{http://www.masswerk.at/jsuix\ul0\cf0}}}}\f0\fs28\par
\par
\par
\b The most commonly used basic commands\b0  :\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \par
1) pwd  --> print working directory\par
\par
2) ls  --> list out all files and directories.\par
\par
3) mkdir --> To create/ make a directory.\par
\par
4) cd  --> change directory\par
\par
5) touch --> to create an empty file\par
\par
6) rmdir --> to remove a directory\par
\par
7) rm --> to remove a file.\par
\par
8) cal --> display current month calender\par
\par
9)date --> display current date and time.\par
\par
10) help --> To display list of available commands.\par
\par
11) clear --> To clear the terminal.\par
\par
12)  exit --> To logout session\par
\par
13) hello --> To display brief system information \par
\par
\par
\b\fs32 Linux File System :\b0\fs28\par
- - - - - - - - - - - - - - - \par
\par
\b Types of Files in Linux:\par
- - - - - - - - - - - - - - - - - \par
\par
\b0 In python everything is treated as an object.\par
\par
In Linux everything is treated as a file.\par
\par
1) Normal files or ordinary files.\par
\par
2) Directory Files\par
\par
3) Device Files.\par
\par
\b 1) Normal files or ordinary files:\par
\b0 - - - - - - - - - - - - - - - - - - - - - - - - \par
These files contain data. It can be normal text file or binary files (images,video,audio files etc..)\par
\par
abc.txt\par
test.sh\par
test.py\par
Test.java\par
sunny.jpg\par
bahubali.mp4\par
\par
In Linux file extension is not important. based on our content the linux can identify file type.\par
\par
\b 2) Directory files:\b0\par
 - - - - - - - - - - - - -\par
\par
These files represent directories .\par
In Windows, we can use folder terminology but in linux we can use directory terminology.\par
directory contains files and sub directory also.\par
\par
\b 2) Device files:\b0\par
 - - - - - - - - - - - - -\par
In Linux every device is represented as a file.\par
By using this file we can communicate with that device.\par
Inside  /dev directory all device related files will be there.\par
\par
tty is used to get the current terminal location.\par
\par
terminal 1====>  /dev/pts/0\par
terminal 2 ====> /dev/pts/1\par
\par
\b Note:\par
\b0 ctrl+alt+t ===> To open terminal \par
ctrl+d       ===>  To close terminal\par
\par
\b How to Check file type:\par
- - - - - - - - - - - - - - - - - - \par
\par
\b0 In ubuntu:\par
blue colour files represents :directories\par
remaining :ordinary files\par
\par
we have to use ls -l   command to find out file type.\par
\par
The First charector represents the type of file\par
\par
d ---> directory file\par
 -    ===> ordinary file\par
l   ====>link file\par
\par
\par
c ===> charector special file\par
b ===> block special file\par
s ====> socket file\par
\par
\par
\b File System navigation Commands:\par
-  - - - - - - - - - - - - - - - - - - - - - - - - - - \par
\par
\b0 hidden files and hidden directories\par
\par
ls \par
ls  -a\par
     -a means all \par
\par
. represents current directory\par
. .  represents parent directory\par
\par
/home/durga/Desktop/dir1/dir2\par
\par
if you are in dir2\par
\par
current directory :dir2\par
parent directory :dir1\par
\par
cd command\par
\par
1) $ cd .\par
  changes to current directory (useless)\par
\par
2) $ cd . .\par
  changes to parent directory\par
\par
3)$ cd . ./. ./. ./. .\par
\par
4)$ cd ~\par
    To go to user home directory\par
\tab   /home/durga\par
\par
5) $ cd \par
    cd command   without  any argument \par
\tab  To go to user home directory\par
\tab  /home/durga \par
\par
6) $ cd -\par
\tab    If we want to go previous working directory\par
\par
\par
\par
\b Linux File System Hierarchy :\par
- - - - - - - - - - - - - - - - - - - - - - \par
\par
\b0 Linux file system has Tree like structure.\par
It starts with root(/)\par
/ is th topmost directory\par
\par
sub directories:\par
bin   etc    home     lib     dev       usr cdrom  \par
\par
\b 1) bin directory :\b0  \par
- - - - - - - - - - - - -\par
bin means binary \par
It  contains all binary excecutable related to our linux commands.\par
\par
touch \par
ls \par
mkdir\par
cd \par
\par
\b 2) sbin directory:\par
- - - - - - - - - - - - - \par
\b0 sbin means systembin.\par
normal user commands related binary executable files available in bin directory.\par
\par
super user used commands related binary executable files available in bin directory.\par
\par
Disk partitioning \par
Network management\par
\par
\b 3) etc directory:\par
- - - - - - - - - - - - - \b0   \par
This directory contains all system configuration files.\par
These configuration files can be used by operating system itself.\par
\par
/etc/passwd  ==> All users information.\par
/etc/group    ==> All groups information\par
/etc/hosts     ==> All hosts information( ip address and dns names).\par
\par
 \b 3) tmp directory:\par
  - - - - - - - - - - - - -\par
\par
\par
\par
\fs36 Installing Linux Operating System:\par
- - - - - - - - - - - - - - - - - - - - - - - - - - -\par
\par
\b0\fs28 step1: oracle virtual box installation\par
\par
step2: Ubuntu installation\par
\par
\b Need of Virtual box:\b0\par
\b - - - - - - - - - - - - - - - \par
\b0 To run virtual computers in our system without effecting original computer \par
\par
Computer ===>\par
Virtual Box ===>\par
         Virtual computer ===> Linux \par
\tab\tab   Virtual Computer ===> Mac\par
         Virtual Computer ===> Sun solaries\par
\par
By using this virtual box we can run multiple operating system simultanously.\par
\par
\par
\b Oracle Virtual Box Installation:\par
- - - - - - - - - - - - - - - - - - - - - - - -\par
\par
\b0 Download virtual box software from virtualbox.org\b\par
\b0\par
In this virtual box, we have to create virtual computer with ubuntu operating system\par
\par
ubuntu software must be required.\par
 download ubuntu from ubuntu.com\par
\par
\par
1. ls command:\par
- - - - - - - - - - - \par
list out all files and directories present in the given directory.If we are not providing any directory then it will list out in current working directory.\par
$ ls dir1\par
$ ls\par
$ man command\par
$ man ls\par
various options for ls commands:  \par
- - - - - - - - - - - - - - - - - - - - - - - - \par
1. ls \par
It will list out all files and directories present in current working directory in alphabetical order.\par
2. ls -r \par
-r means reverse \par
It will list out all files and directories  in riverse of alphabetical order.\par
\par
3. ls -l \par
To display in long listing form \par
\par
-rw-r - - r - - 1  durga durga                0  Mar 23  12:40  abcdef.txt\par
 \par
\par
4. ls -t\par
-t means creation or last modified time.\par
Most recent will be at the top and old are at the bottom.\par
5. ls -ltr\par
old files should be at top and most recent should be at bottom.\par
6. ls -a \par
 -a means all.\par
7. ls -A\par
-A means almost all\par
except  . and . .  all remaining things will be displayed \tab\par
8. ls -F\par
To display all files by type\par
directory  ----> /\par
executable file ----> *\par
link file -----> @\par
9. ls -f \par
list out all files including hidden files but disable  colors.\par
10. ls  -i\par
To display all files including inode number \par
inode ===>index node\par
i- node is the adress of location where file attributes are stored. file attributes includes\par
The size of the file.\par
The number of links in the file.\par
owner name\par
group name\par
creation time\par
last modified time\par
11. ls -R\par
  -R Means recursive\par
which is used to show all sub directories in each individual sub directory.\par
12. ls -s \par
-s means size \par
the number of blocs used \par
1 block =1kB or 4KB\par
13. ls -h\par
-h means human readable form for memory statistics.\par
\par
Note:\par
ls  -l  /etc  ===> 212 entries\par
ls  -l  |  head  ====> top 10 entries\par
ls   -l  | head  -20  ===> top 20 entries\par
ls   -l  | head -30   ====> top 30 entries\par
ls   -l   | tail   ===> last 10 lines\par
\par
ls  -l  /etc  | more   ===> only in farward direction \par
ls  -l  /etc  | less    ===> both in forward and backward direction\par
\par
\par
Command Line Arguments:\par
- - - - - - - - - - - - - - -- - - - - - \par
The  Arguments which are passing from command prompt  ===> \par
$   ./test.sh  10   20   30   40\par
\tab         10,20,30,40\par
$  ./test.sh   learning linux is very easy \par
learning, linux, is, very,easy\par
$ #  ----> Number of arguments  (5)\par
$ 0  -----> Script Name (./test.sh)     test.sh ====> /home/durga/ scripts /test.sh\par
$ 1  -----> First argument (learning) \par
$ 2  -----> Second argument (linux)\par
$ 3  ----- > Third argument (is)\par
$ 4 -----> Fourth argument ( very)\par
$ 5  -----> Fifth argument (easy)\par
$ *  ------> all arguments  (learning linux is very easy)\par
$ @ ------> All arguments ( learning linux is very easy)\par
$ ?  -------> Represents exit code of Previuosly executed  command or Script.\par
\par
test.sh File \par
#!   /bin /bash\par
echo   "The number of arguments  : $#"\par
echo  "Script file name : $0"\par
echo "First argument :$1"\par
echo "Second argument: $2"\par
echo "Third argument : $3"\par
echo "Fourth argument :$4"\par
echo "Fifth  argument :$5"\par
echo "All arguments with * : $*"\par
echo "all arguments with @ :$@"\par
\par
Difference between $@ and $*:\par
- - - - - - - - - - - - - - - - -- - - - - -\par
$@:  -----> All commands line arguments with space seperator.\par
                     "$1"    "$2"   "$3"   "$4"    "$5"\par
                     learning linux is very easy\par
$*   ------>  All  command line arguments as single  string .\par
                     "$1c$2c$3c$4c$5"\par
                     where c is the first charecter of the IFS  (Internal file seperator) . The default is \tab\tab     space .\par
\tab    learning  linux is very easy.\par
\par
How to check default  IFS :\par
- - - - - - - - - - - - - - - - -  - - -\par
$ set  | grep  "IFS"\par
\par
IFS =$  '   \\t\\n'\par
\b\par
What is the main purpuse of command line arguments:\par
- - - - - - - - - - - - - - - - -  - - - - -  - - - - - -- - - - - - - - - - - - - - - \par
\par
\b0 we can customize behaviour  of the script Based on our arguments the script will work.\par
\par
test.sh:\par
- - - - - \par
\par
#! /bin/bash\par
len = $(echo -n "APPLE" | wc -c)\par
echo "The length of given string :$len"\par
\par
The script will always work for the string :APPLE\par
\par
test.sh:\par
- - - - - -\par
#! /bin /bash\par
\par
len =$(echo -n "1$" |wc -c)\par
echo "The length of given String $1 : $len"\par
\par
\par
\b Variable Substitution and command substitution:\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\par
\par
write a script to create a log file with time stamp:\par
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - -\par
\par
\b0 test.sh:\par
- - - - - \par
#!  /bin/bash\par
\par
timestamp = $ (date  +%d_%m_%Y_%H_%M_%S)\par
\par
echo "Hello " > abc.text   overwrite existing data\par
echo "Hello"  >> abc.txt   append to existing data\par
echo  "This is data to log file " >> $ \{timestamp\}.log\par
date  >> $ \{timestamp\}.log\par
\par
\par
\par
\b\fs32 How to view content of the file:\par
\b0\fs28 - - - - - - - - - -  - - - - - - - - - - - - - - - - - - -\par
we can view the content of the file by using the following commands:\par
\par
1. cat \par
2. tac\par
3. rev\par
4. head\par
5. tail\par
6. more \par
7. less\par
 \par
\b View content by using cat:\par
- - - - - - - - - - - - - - - - - - - - -\par
\b0 cat  < file.txt\par
where  < is optional.\par
cat file1.txt\par
\par
while display data if we want line numbers, we have to use -n option.\par
cat  -n file1.txt\par
\par
Numbering skipped for blank lines then we should use -b option\par
\par
\b To View Multiple files content simultanously:\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \par
\b0 cat file1.txt   file2.txt    file3.txt   \par
\par
\b Various utilities of cat command:\b0\par
- - - - - - - - - - - - - - - - - - - - - - - - - \par
\par
1. create a new file with some content \par
\par
cat > file1.txt\par
required data\par
ctrl+d   ---> to save and exit\par
\par
2. To append some extra data to an existing file:\par
\par
cat  > > file1.txt\par
some more extra data\par
ctrl+d  ----> to save and exit\par
\par
3. To view content of the \tab file:\par
\par
cat < file1.txt      or     cat  file1.txt\par
\par
4 . To copy content of one file to onether file:\par
\par
cp file.txt    file2.txt\par
\par
cat file1.txt   > file2.txt\par
\par
5. To append one file to onether file:\par
\par
cat    file1.txt  >>   file2.txt\par
\par
6. To copy contents of multiple files to a single file:\par
\par
cat  a.txt    b.txt    c.txt   d.txt     >total.txt\par
\par
\b\fs32 2. tac command\par
\par
\b0\fs28 It is the reverse of cat \par
\par
It will display file content in riverse order of lines.\par
\par
this is vertical riversal.\par
\par
\par
Sunny \par
Bunny \par
chinny\par
vinny\par
pinny\par
\par
\par
Pinny\par
vinny\par
chinny\par
bunny\par
sunny\par
\par
\b\fs32 3. rev command:\par
\b0\fs28\par
rev means reversal.\par
Here each line will be reversed.\par
It is horizontal reversal.\par
\par
\par
Sunny \par
Bunny\par
Chinny\par
Vinny\par
Pinny\par
\par
\par
\par
ynnuS\par
ynnuB\par
ynnuhC\par
ynnuV\par
ynnuP\par
\par
\par
cat command will display total file content at a time. It is best suitable for small files. If the file contains thousands of lines it is not recommended to use cat command. For this requirement we should go for\par
\par
head \par
tail\par
more \par
less\par
\par
\par
\b\fs32 head command:\b0\fs28  \par
- - - - - - - - - -- - - - - \par
\par
To view specified number of lines from top of the file \par
\par
head  abc.txt\par
\par
It will display only 10 lines from top of file .\par
10 is the default value for head command.\par
\par
head  -n  15 abc.txt     or    head    -15    abc.txt\par
\par
head -5  abc.txt\par
\par
head  -n   -5  abc.txt \par
It will display all lines from top except last 5 lines.\par
\par
head -c  100  abc.txt\par
\par
It will display the first 100 charectors of the file \par
\par
In linux every charector will take one byte. Hence it will display first 100 bytes of the file  Content. \par
\par
\b\fs32 tail command:\b0\fs28  \par
- - - - - - - - - - - -- - \par
\par
To view file content from bottom of the file  ---> tail command \par
It is opposit to head command.\par
\par
1. tail   abc.txt\par
Last 10 lines will be dispayed\par
\par
2. tail -n 5  abc.txt\par
 Last 5 lines \par
\par
 tail -5  abc .txt \par
  Last 5 lines \par
\par
tail -5 -n abc.txt\par
Last 5 lines           //in head command except last 5 remaining will display but here that is not implimented\par
\par
3. tail -c 100 abc.txt\par
    It will display 100 bytes of content from bottom of the file.\par
\par
Q. Assume file contains enough data. \par
\par
write command to display from 3rd line to 7th line?\par
\par
head  -7 abc.txt  | tail -5 \par
\par
\b\fs32 Word count command ( wc command ) :\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\par
\par
\b0\fs28 we can use wc command to count number of lines,words and charectors present in the given file\par
\par
$ wc  filename \par
 \par
no_of_lines       no_of_words      no_of_charectors    file_name\par
\par
durga@durga - VirtualBox:~/Desktop$   wc file1.txt\par
 4    24     135   file1.txt \par
\par
\par
4  -----> No of lines\par
24 -----> No of words \par
135 ----> No of charectors ( no of bytes or filesize)\par
\par
we can use the following options with wc command \par
\par
-l      ====> To print only number of lines \par
-w    ====> To print only number of words \par
-c     ====> To print only number of charectors\par
-lw   ====> To print only number of lines and words\par
-lc    ====> To print only number of lines and charectors\par
-wc  ====> To print only number of words  and charectors\par
-L     =====>To print number of charectors present in Longest Line \par
\par
We can use  wc command for multiple files simultanously.\par
\par
wc  a.txt  b.txt  c.txt\par
\par
durga@durga - VirtualBox:~/Desktop$   wc file1.txt    file2.txt   file3.txt\par
\par
4    24    135    file1.txt\par
4    24    135   file2.txt\par
3    9      47      file3.txt\par
11  57   317    total\par
\par
\par
\par
\b\fs32 What is Piping:\b0\fs28   \par
- - - - - - - - - - - - - \par
some times we can use output of one command as an input to other command. This concept is called piping.\par
\par
By using piping, multiple commands will work together to fulfill  our requirements\par
\par
we can implement piping by using vertical bar  (|)\par
\par
eg-1:\par
durga@durga-VirtualBox:~Desktop$   ls -l  /etc | wc -l\par
222\par
\par
standard output of ls command will become standard input to wc command \par
\par
eg -2:\par
ls -l /etc  | more\par
\par
eg -3:\par
ls -l  /etc  |  head -5\par
\par
eg -4 : ls -l  /etc  | wc  |wc -1\par
\par
the output is always 1.\par
\par
\b Requirement:\b0  \par
The output of ls command should be saved to the file  output.txt  and should be provided as input to wc command ?\par
\par
ls - l  > output.txt  | wc  -l\par
\par
In the middle of piping if we use redirection then it breaks piping concept.\par
\par
ls -l\par
\par
\par
\b tee command:\par
- - - - - - - - - - - \par
\par
\b0 ls  - l  | tee  output.txt  |wc\par
\par
In piping, if we want to save the output of one command to a file and if we want to pass that output as input to next command simoultaniously  then we should use tee command .\par
\par
eg1:  To save the output of ls command to a fille and display to the terminal simultaneously\par
\par
ls   - l   | tee output.txt\par
\par
eg 2:\par
If i want to save the result of ls -l in output.txt and pass the output to wc command and save that output in wc.txt ?\par
\par
ls -l  | tee output.txt |wc  | tee  wc.txt\par
\par
\par
\b Requirement 2:\par
- - - - - - - - - - - \par
 \b0 Assume input.txt  contains filenames.\par
\par
input.txt\par
- - - - - - \par
\par
file1.txt \par
file2.txt\par
file3.txt\par
\par
Read file names from the input.txt  and remove each file.\par
\par
cat input.txt  ===> standard output \par
rm  file1.txt    file2.txt   file3.txt    ===>  remove 3 files\par
\par
remove command always expecting from command line arguments only.\par
 But in piping the input is always stream.\par
\par
cat   input.txt | rm\par
\par
we have to convert that stream into command line arguments\par
\par
xargs  command:\par
- - - - - - - - - - - - \par
cat  input.txt  | xargs  rm\par
\par
xargs command:  to convert output stream into command line argument  \par
\par
\par
eg2: Assume input.txt contains multiple file names. Read all these file names from input.txt and display the files content to the terminal ?\par
\par
cat input.txt \par
       a.txt\par
\tab\tab b.txt\par
\tab\tab c.txt\par
\par
cat a.txt  b.txt   cat c.txt\par
\par
cat input.txt  |  xargs  cat\par
\par
eg3: Display the output of date command by using echo command with piping concept?\par
\par
date | xargs echo\par
\par
eg:4\par
List out all contents of  /dev folder and save to file1.txt\b\par
\b0 List out all contents of /bin folder and save to file2.txt\par
\par
write a single pipeline for the following requirement:\par
read contents of file1.txt and file2.txt and save to file3.txt. By using  sort command reverse the content of  file3.txt and saved to sorted.txt file.\par
\par
ls  /dev  >file1.txt \par
\par
ls  /bin  > file2.txt\par
\par
 // cat file1.txt   file2.txt   >file3.txt  sort   -r  file3.txt  >  sorted.txt\par
\par
cat file1.txt  file2.txt | tee file3.txt | sort  -r >sorted.txt\par
\par
\par
\par
\b\fs36 Command  Aliasing:\par
\b0\fs28 - - - - - - - - - - - - - - - - - - -\par
\par
Alias means alternative name or nick name.\par
\par
we can give our own more convinient nicknames for unix commands. This concept is called command aliasing.\par
\par
How to create alias name:\par
- - - - - - - - - - - - - - - - - - - \par
we have to use alias command \par
$ alias\par
\par
\par
$ alias nickname='original command '\par
\par
$ alias nickname="original command"\par
\par
$ alias nickname=original command\par
\par
Note: No spaces allowed before or after = symbol .\par
\par
How to remove alias name:\par
- - - - - - - - - - - - - - - - - - - - \par
we have to use unalias\par
\par
$ unalias   command_name\par
\par
$ unalias  cls\par
\par
$ unalias  -a\par
 \par
\par
I want to define alias name, but how to check is it available already?\par
\par
Just use type command\par
\par
\par
\par
durga@durga - VirtualBox:~/Desktop$  type cls\par
\par
cls is alialsed to clear\par
\par
durga@durga - VirtualBox:~/Desktop$ type cls1\par
\par
bash:type :cls1: not found\par
\par
\par
Where we can use aliasing :\par
- - - - - - - - - - - - - - - - - - - - -\par
1. If any lengthy command repeatedly required, then we can create shortcut alias name and we can use that shortcut everytime.\par
\par
eg:\par
mkdir dir1;  touch dir1/file1\{1..20\}.txt\par
\par
alias d20f ='mkdir dir1;  touch dir1/file1\{1..20\}.txt'\par
\par
eg2: To list out all files present in current working directory, save this data to output.txt  and display the number of lines to the terminal. Define alias name  'current'  for this total activity?\par
\par
alias  current = 'ls-l | tee  output. txt  | wc -l'\par
\par
2. To use our home operating  system commands in linux directoly \par
\par
windows \par
mac\par
 alias  cls ='clear'\par
 alias  rename ='mv'\par
\par
3. To handle typing mistakes\par
\par
grep \par
grpe\par
alias grpe='grep'\par
\par
4. To handle language barriers:\par
- - - - - - - - - - - - - - - - - - - - - - - \par
\par
In germany =====>datum\par
\par
alias datum = 'date'\par
\par
cp \par
koopy\par
\par
alias koopy = 'cp'\par
\par
How to persist aliases perminently:\par
- - - - - - - - - - - - - - - - - - - - - - - - - -\par
we can make our created aliases permanently in our system by using 2 ways \par
\par
1st way:\par
- - - - - -\par
.bashrc  file inside our user home directory\par
\par
# my own aliases \par
\par
alias  cls='clear'\par
alias  ddd='date;date;date'\par
alias  dd='date;date;\par
\par
To reflect these changes  we have to restart terminal\par
\par
instead of restarting terminal we can use       source   .bashrc     // not working\par
\par
2nd way:\par
- - - - - - - \par
Instead of editing  .bashrc file, we can create our own file to maintain our defined aliases .\par
\par
The name of the file should be  .bash_aliasis and should be present in our home directory.\par
 \par
\b\fs36 Regular expressions :\par
\b0\fs28 - - - - - - - - - - - - - - - - - - - - - \par
\par
1. To list out all files present in current working directory?\par
\par
$ ls  *\par
\par
2. To list out all files with some extension?\par
$ ls  *.*\par
\par
3. To list out all  .txt files\par
$ ls  *.txt\par
\par
4. To list out only  .java files \par
 $ ls  * .java\par
\par
5. To list out all files starts with  a\par
$ la a*\par
\par
6. To list out all files where file name contains only  2 charectors and first charectors should be  a\par
\par
$ ls  a?\par
\par
7. To list out all files where file name contains only  2 charectors \par
\par
$ ls   ??\par
\par
8. To list out all files where file name contains only  3 charectors \par
$ ls  ???\par
\par
9. To list out all files where file name contains atleast 3 charectors \par
$ ls  ???*\par
\par
10. To list out all files where file name starts with a or b or c\par
\par
$ ls  [abc] *\par
\par
11. To list out all files where file name should not starts with a or b or c\par
\par
$ ls  [!abc]*\par
\par
12. To list out all files where file name starts with lowercase alphabet symbol?\par
\par
$ ls [a-z] *\par
$ ls [[:lower:]]*\par
\par
13.To list out all files where file name starts with uppercase alphabet symbol?\par
\par
$ ls  [A-Z]*\par
$ ls [[:upper:]]*\par
\par
14. To list out all files where file name starts with digit?\par
$ ls [0-9]*\par
$ ls [[:digit:]]*\par
\par
15. To list out  all files where first letter should be upper case alphabet symbol, second letter should be digit and third letter should be lower case alphabet symbol?\par
\par
$ ls [A-Z] [0-9] [a-z]\par
$ ls [[:upper:]] [0-9] [[:lower:]]\par
$ ls [[:upper:]] [[:digit:]] [[:lower:]]\par
\par
16. To list out all files starts with special symbol.\par
$ ls [![:alnum:]]*\par
\par
17.To list out all files with .java or .py extension?\par
$  ls \{* .java, * .py\}\par
$  ls *.\{java ,py\}\par
\par
Note: we can use regular expression and wild card charecters with other commands also  like  rm,cp, mv, etc\par
\par
18. To copy all files starts with digit to dir1 directory?\par
\par
cp [0-9]*  dir1\par
\par
cp [[:digit:]]*  dir1\par
\par
19. To move all files starts with alphabet symbol and with  .txt extension to dir2  directory?\par
\par
$  mv [[:alpha:]]* .txt    dir2\par
\par
20. Remove all files starts with a or b or c and ends with e or t?\par
\par
$ rm [abc]* [et]\par
\par
\par
Q1: which command will list all files that has exactly three charecters present in current working directory?\par
\par
$ ls ???\par
\par
Q2: which command will copy all files that ends with  .pdf to dir1?\par
\par
cp  * .pdf   dir1\par
\par
Q3: which command will move all the files that begins with letter a and ends with letter n to dir1?\par
$ mv a* n  dir1\par
\par
Q4: which command will display content of all files that begins with a digit and ends with a or e or i or o or u?\par
\par
cat [0-9] * [aeiou]\par
\par
cat [[:digit:]] * [aeiou]\par
\par
Q5:which command will list all files that begins with a lower case alphabet symbol and has a letter d in the third charecter position, and ends  with an upper case letter?\par
\par
$ ls [[: lower :]] ? d*[[:upper:]]\par
\par
Q6: which command will list all  .jpg files present in Pictures  directory ?\par
\par
ls  /home/durga/Pictures/ *.jpg\par
\par
ls ~/Pictures/*.jpg\par
\par
Q7. which of the following regular expression will match file named with demoA.txt?\par
\par
demoA.txt\par
\par
A) *\par
B)  demo ? .txt\par
C) demo*\par
D) * .txt\par
E) demo [A-Z].txt\par
F) All of the above\par
\par
Ans: F\par
\par
Q8. which of the following regular expressions can represent the files:\par
student_reportA.pdf\par
student_reportB.pdf\par
student_reportC.pdf\par
\par
a) ??.\par
b) report*.pdf\par
c) *[A-Z]\par
d) student*.pdf\par
\par
Ans:c,d\par
\par
\par
\b\fs32 JACKPOT ASSIGNMENT :\par
\b0\fs28 - - - - - - - - - - -  - - - - - - - - - -\par
\par
mkdir  jackpot /dir\{1..100\}\par
touch jackpot/dir\{1..100\}/file\{1..100\}.txt\par
\par
touch jackpot/dir $ (shuf -i  1-100  -n 1) /sunny.txt\par
\par
find sunny.txt and move to desktop\par
\par
find jackpot  -type  f  -name  'sunnt.txt'  -exec  mv  \{ \}  ~/Desktop  \\;\par
\par
mv sunny.txt   ~/Desktop\par
\par
Remove all text files in jackpot directory\par
\par
find  jackpot  -type  f  -name  '*.txt'  -exec  rm \{ \}  \\;\par
\par
Remove all files inside jackpot directory including jackpot directory\par
\par
find jackpot  -type  d -exec  rm -r  \{\}  \\;\par
\par
Q1: The command uses a database to search files and directories?\par
\par
a) true\par
b) false\par
\par
Q2: To find files and directories inside  /dev folder and limits its search to only 2 levels of depth?\par
find   /dev   -maxdepth  2\par
\par
Q3: To find only directories inside   /dev  folder and limits its search to only 2 levels of depth?\par
\par
find   /dev   -maxdepth  2  -type d\par
\par
Q4: To find only files starts from root directory  (/) where file name ends with  .txt?\par
\par
find / -type  f  -name  ' *.txt'\par
\par
find  / -type  f -iname '*.txt'\par
\par
Q5: To find all files and directories inside  /dev  directory  upto maximum 3 levels of deep and size is greater than  200kilo bytes?\par
\par
find  /dev  -maxdepth 3  -size +200k\par
\par
Q6: which command will find all files below our home Directory where file size is greater than 3 mega Bytes and remove all those files?\par
\par
find  ~  -type  f  -size  +3M  -exce rm  \{\}  \\; \par
\par
Q7: find command make our life is very easy to delete last 6 months files\par
\par
/usr/bin/find/home/stack/zabbix_metrics/*.csv  -mtime  +180  -exec  rm -rf  \{\} /; >dev/null 2>&1\par
\par
find   /home/stack/zabbix_metrics/*.csv  -mtime  +180  -exec  rm -rf  \{\} /; >dev/null 2>&1\par
\par
\par
\b\fs36 Grep (global regular expression print):\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - -\fs28\par
\b0\par
grep [options]   pattern   [file]\par
\par
cat filename  |  grep pattern\par
\par
with out any option we can use like this\par
grep "UNIX" grepfilter.txt\par
cat  grepfilter.txt   | grep  "Linux"\par
\par
Options:\par
- - - - - - \par
1) c:   grep  -c  pattern file  -display number of matching lines\par
\par
grep  -c "UNIX"  grepfilter.txt\par
\par
\par
2) h:   grep -h pattern file -display all matching lines\par
\par
grep  -h "UNIX"  grepfilter.txt\par
\par
3) l:   grep -l  pattern * -display all the file names in which pattern matches\par
\par
grep -l "o" *\par
\par
4) n :   grep  -n  pattern file  -display all the matching lines with Line numbers \par
\par
grep -n  "UNIX" grepfilter.txt\par
\par
\par
5) v:   grep  -v pattern file  -display all the non matching lines\par
\par
grep -v  "UNIX" grepfilter.txt\par
\par
6) o:   grep -o pattern file -display only the matching pattern\par
\par
grep -o "Unix" grepfilter.txt\par
\par
7) e:   grep -e pattern file  -use multiple search patterns\par
\par
grep  -e "UNIX"   -e  "LINUX"  grepfilter.txt\par
\par
8) ^:    grep ^ pattern file -match the lines which starts with given pattern\par
\par
grep  ^ Welcome   grepfilter.txt\par
\par
9) $ :   grep pattern $ file  -display the lines which ends with given pattern\par
\par
grep  ands$  grepfilter.txt\par
\par
10) i :  grep pattern file  -case insensitive searching\par
\par
grep -i "unix" grepfilter.txt\par
\par
\par
\b egrep command:\par
- - - - - - - - - - - - - \par
\b0\par
Instead of using  -e option we can use  egrep command.\par
\par
egrep means extended grep\par
\par
egrep    '(java|linux)'   demo.txt\par
\par
egrep  command can understand this pattern and process this pattern.\par
\par
grep command always looking for the match: "(java|linux)"\par
\par
\par
grep command can understand patterns  --> yes but not all patterns\par
\par
'^linux'   is understandable by grep \par
'(java| linux)'  cannot understandable by grep\par
'[0-9] \{9\} ' cannot understandable by grep\par
\par
egrep command can understand patterns  ---> yes all patterns \par
\par
'^linux'\par
'(java|linux)'\par
\par
\par
grep command with -F options:\par
- - - - - - - - - - - - - - - - - - - - - - - -\par
-F  means Fixed Strings \par
\par
If we want to search for a group of fixed strings then we should go for -F option.\par
\par
grep  -F  "java\par
>linux\par
>python" demo.txt\par
\par
The strings should be seperated by  new line charactor.\par
\par
Instead of  -F option, we can use  fgrep  command \par
\par
fgrep  means   ----> Fixed String Global Regular Expression print\par
\par
fgrep command can understand patterns ---> no\par
\par
we have to provide only fixed strings\par
\par
in file1.txt \par
java\par
linux\par
python\par
\par
we have a file called demo.txt so we need to search three words in that file those three words are java, linux, python is saved inside file1.txt\par
\par
fgrep  -f  file1.txt  demo.txt\par
\par
\par
\b\fs36 cut command:\par
- - - - - - -- - - - -\par
\b0\fs28 we can use cut command to extract data from the file.\par
The file can be either normal file or tabular file.\par
\par
nornal file:\par
- - - - - - - - \par
first line \par
second line\par
third line \par
\par
tabular file:\par
- - - - - - - - - \par
\par
emp.dat\par
\par
e.no | ename | esal | eadrs |dept  |gender\par
100  | sunny   | 100 |hyd\tab     |hr       |male\par
200  | tejas     | 200 |wgl\tab     |dvps   |male\par
300  | sharma| 100 |hyd\tab     |hr       |male\par
\par
\par
1. Display character on the specific position in every record ?\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\par
\par
cut  -c  9  emp.dat\par
\par
-c means for specific charector\par
\par
2. Display range of charaters in every record:\par
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \par
\par
cut -c  5-9 emp.dat\par
 \par
    It will display 5th to 9th charactor in every record\par
\par
cut  -c   5 -   emp.dat\par
    It will display  5th character to last character in every record\par
\par
cut -c  -3  emp.dat\par
   \par
It will display 1st charactor to 3rd charactor in every record\par
\par
cut -c  3-5,7-10  emp.dat \par
  It will  display 3rd to 5th characters and 7th to 10th charactars in every line \par
\par
3. Display specific column data:\par
- - - - - - - - - - - - - - - - - - - - - - - -\b\fs36\par
\b0\fs28 $ cut -d  "|" -f  3  emp .dat\par
\par
-d means delimiter  (seperator). The default delimeter is tab.\par
\par
-f means field \par
\par
4. Display Range of Columns:\par
- - - - - - - - - - - - - - - - - - - - - -\par
cut  -d  "|"  -f  2-4  emp.dat\par
\par
cut -d   "|"  -f   2-   emp.dat\par
\par
cut -d   "|"   -f   -4    emp.dat\par
\par
To display 1st, 3rd and 5th columns \par
\par
cut  -d  "|"  -f  1,3,5  emp.dat\par
\par
5. Skip specific Column :\par
- - - - - - - - - - - - - - - - - -\par
Display all columns except specific column \par
--compliment \par
\par
cut   -d   "|"   --compliment   -f  3,5  emp.dat \par
\par
It will  display all columns except 3 and 5 .\par
\par
cut  -d  "|"  --compliment   -f  3,5  emp.dat\par
cut  -d  "|"  --compliment   -f  3-5  emp.dat\par
cut   -d  "|"  --compliment  -f   3 -  emp.dat\par
\par
\par
\b\fs36 Paste  command:\par
- - - - - - - - - - - - - \par
\b0\fs28 we can use paste command to join two or more files horizontally by using some delimator. Default delimator is Tab .\par
\par
paste file1.txt  file2.txt  file3.txt  .....\par
\par
subjects.txt\par
- - - - - - - - -\par
Core java  \par
Adv Java\par
Python\par
Ui\par
Linux\par
\par
fee.txt\par
- - - - - \par
1000\par
2000\par
3000\par
4000\par
5000\par
\b\fs36\par
\b0\fs28\par
\par
  \par
\par
\par
 \par
\par
\b\par
\par
\par
\b0\par
\par
\b\fs32\par
\b0\fs28\par
\par
\par
\par
     \par
\par
\b\fs32\par
\b0\fs28\par
\par
\par
\par
 \fs22\par

\pard\sa200\sl276\slmult1\par
}
 